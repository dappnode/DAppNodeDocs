"use strict";(self.webpackChunkd_app_node_docs=self.webpackChunkd_app_node_docs||[]).push([[8177],{60743:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>n,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"smooth/deep-dive-into-smooth/oracle-sm","title":"Smooth\'s architecture","description":"Smooth is composed of two main components: the Oracle and the Smart Contract. These two components work together to track validators and distribute rewards fairly. Both are open source and indispensable to the functioning of Smooth. While the Smart Contract serves to track all the events related to the pool onchain (subscriptions, unsubscriptions, block proposals, etc.), the Oracle is responsible for computing the rewards of each validator.","source":"@site/docs/smooth/deep-dive-into-smooth/oracle-sm.md","sourceDirName":"smooth/deep-dive-into-smooth","slug":"/smooth/deep-dive-into-smooth/oracle-sm","permalink":"/docs/smooth/deep-dive-into-smooth/oracle-sm","draft":false,"unlisted":false,"editUrl":"https://github.com/dappnode/DappnodeDocs/edit/master/docs/smooth/deep-dive-into-smooth/oracle-sm.md","tags":[],"version":"current","frontMatter":{"title":"Smooth\'s architecture","llm_description":"Explains Smooth\'s Oracle and Smart Contract architecture for tracking validators and rewards."},"sidebar":"smoothSidebar","previous":{"title":"Validator States","permalink":"/docs/smooth/deep-dive-into-smooth/states"},"next":{"title":"Avoid proposing Vanilla Blocks","permalink":"/docs/smooth/deep-dive-into-smooth/vanilla-blocks"}}');var r=o(74848),a=o(28453);const n={title:"Smooth's architecture",llm_description:"Explains Smooth's Oracle and Smart Contract architecture for tracking validators and rewards."},i="Smooth's architecture",c={},h=[{value:"The Smart Contract",id:"the-smart-contract",level:2},{value:"The Oracle",id:"the-oracle",level:2}];function l(e){const t={a:"a",admonition:"admonition",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"smooths-architecture",children:"Smooth's architecture"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://smooth.dappnode.io/",children:"Smooth"})," is composed of two main components: the ",(0,r.jsx)(t.strong,{children:"Oracle"})," and the ",(0,r.jsx)(t.strong,{children:"Smart Contract"}),". These two components work together to track validators and distribute rewards fairly. Both are open source and indispensable to the functioning of ",(0,r.jsx)(t.a,{href:"https://smooth.dappnode.io/",children:"Smooth"}),". While the Smart Contract serves to track all the events related to the pool onchain (subscriptions, unsubscriptions, block proposals, etc.), the Oracle is responsible for computing the rewards of each validator."]}),"\n",(0,r.jsx)(t.h2,{id:"the-smart-contract",children:"The Smart Contract"}),"\n",(0,r.jsxs)(t.p,{children:['Smooth\'s Smart Contract is deployed on the Ethereum mainnet and is responsible for "receiving" all the events related to the pool onchain. This includes subscriptions, unsubscriptions, block proposals, and more. Since it is the Smart Contract the one who holds all the ETH collected by the pool, it is from the Smart Contract where all ',(0,r.jsx)(t.a,{href:"https://smooth.dappnode.io/",children:"Smooth"})," users will claim their rewards."]}),"\n",(0,r.jsxs)(t.p,{children:["Computing and storing all rewards calculations onchain would be almost impossible and very expensive, so merkle trees are used to summarize the state of all validators. This allows the Smart Contract to store a single hash onchain that represents the state of all validators subscribed to the pool. This hash is called the ",(0,r.jsx)(t.strong,{children:"Merkle Root"})," and ",(0,r.jsx)(t.strong,{children:"is computed by the Oracle"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"the-oracle",children:"The Oracle"}),"\n",(0,r.jsxs)(t.p,{children:["As mentioned before, ",(0,r.jsx)(t.strong,{children:"the Oracle is responsible for computing the rewards of each validator"}),". It does so by computing a merkle tree that summarizes the state of all validators subscribed to the pool. This merkle tree, computed offchain, is summarized into a ",(0,r.jsx)(t.strong,{children:"Merkle Root"}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"caution",children:(0,r.jsx)(t.p,{children:"Oracle works only with finalized data. This means that Oracle will effectively work with data from a few epochs ago. This is done to ensure that the data Oracle processes is non-reversible and no reorgs are possible."})}),"\n",(0,r.jsx)(t.p,{children:"Once every 28800 slots (4 days), the Oracle sends a transaction to the Smart Contract with the updated Merkle Root."}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:"It is not until the Oracle sends the transaction to the Smart Contract with the updated Merkle Root that the rewards are available to be claimed by the validators. This means that if a validator correctly proposes a block, it will not be able to claim its rewards until the Oracle sends the transaction to the Smart Contract with the updated Merkle Root."})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>n,x:()=>i});var s=o(96540);const r={},a=s.createContext(r);function n(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);